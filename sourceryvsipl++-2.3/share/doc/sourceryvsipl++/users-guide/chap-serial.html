<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter 7. Fast Convolution</title><link rel="stylesheet" href="cs.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.74.0"><meta name="description" content="This chapter describes how to create and run a serial VSIPL++ program with Sourcery VSIPL++ that performs fast convolution. You can modify this program to develop your own serial applications."><link rel="home" href="index.html" title="Sourcery VSIPL++"><link rel="up" href="pt02.html" title="Part II. Example Application"><link rel="prev" href="pt02.html" title="Part II. Example Application"><link rel="next" href="sec-serial-temporal-locality.html" title="7.2. Serial Optimization: Temporal Locality"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 7. Fast Convolution</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pt02.html">Prev</a> </td><th width="60%" align="center">Part II. Example Application</th><td width="20%" align="right"> <a accesskey="n" href="sec-serial-temporal-locality.html">Next</a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="chap-serial"></a>Chapter 7. Fast Convolution</h2></div><div><div class="abstract"><p class="title"><b>Abstract</b></p><p>This chapter describes how to create and run a serial VSIPL++
      program with Sourcery VSIPL++ that performs fast convolution. You can
      modify this program to develop your own serial applications.</p></div></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="chap-serial.html#sec-serial-fastconv">7.1. Fast Convolution</a></span></dt><dt><span class="section"><a href="sec-serial-temporal-locality.html">7.2. Serial Optimization: Temporal Locality</a></span></dt><dt><span class="section"><a href="sec-io-user-spec-storage.html">7.3. Performing I/O with User-Specified Storage</a></span></dt><dt><span class="section"><a href="sec-io-extdata.html">7.4. Performing I/O with External Data Access</a></span></dt></dl></div><p>This chapter explains how to use Sourcery VSIPL++ to perform
  <em class="firstterm">fast convolution</em> (a common signal-processing kernel).
  First, you will see how to compute fast convolution using VSIPL++'s multiple
  FFT (Fftm) and vector-matrix multiply operations. Then, you will learn how
  to optimize the performance of the implementation.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec-serial-fastconv"></a>7.1. Fast Convolution</h2></div></div></div><p>Fast convolution is the technique of performing convolution in the
    frequency domain. In particular, the time-domain convolution <span class="mathphrase">f
    * g</span> can be computed as <span class="mathphrase">F . G</span>, where
    <span class="mathphrase">F</span> and <span class="mathphrase">G</span> are the
    frequency-domain representations of the signals <span class="mathphrase">f</span>
    and <span class="mathphrase">g</span>. A time-domain signal consisting of
    <span class="mathphrase">n</span> samples can be converted to a frequency-domain
    signal in <span class="mathphrase">O(n log n)</span> operations by using a Fast
    Fourier Transform (FFT). Substantially fewer operations are required to
    perform the frequency-domain operation <span class="mathphrase">F . G</span> than
    are required to perform the time-domain operation <span class="mathphrase">f *
    g</span>. Therefore, performing convolutions in the frequency domain
    can be substantially faster than performing the equivalent computations in
    the time domain, even taking into account the cost of converting from the
    time domain to the frequency domain.</p><p>One practical use of fast convolution is to perform the pulse
    compression step in radar signal processing. To increase the effective
    bandwidth of a system, radars will transmit a frequency modulated "chirp".
    By convolving the received signal with the time-inverse of the chirp
    (called the "replica"), the total energy returned from an object can be
    collapsed into a single range cell. Fast convolution is also useful in
    many other contexts including sonar processing and software radio.</p><p>In this section, you will construct a program that performs fast
    convolution on a set of time-domain signals stored in a matrix. Each row
    of the matrix corresponds to a single signal, or "pulse". The columns
    correspond to points in time. So, the entry at position (i, j) in the
    matrix indicates the amplitude and phase of the signal received at time j
    for the ith pulse.</p><p>The first step is to declare the data matrix, the vector that will
    contain the replica signal, and a temporary matrix that will hold the
    results of the computation:</p><pre class="programlisting"> // Parameters.
 length_type npulse = 64; // number of pulses
 length_type nrange = 256; // number of range cells
 // Views.
 typedef complex&lt;float&gt; value_type;
 Vector&lt;value_type&gt; replica(nrange);
 Matrix&lt;value_type&gt; data(npulse, nrange);
 Matrix&lt;value_type&gt; tmp (npulse, nrange);</pre><p>For now, it is most convenient to initialize the input data to zero.
    (In <a class="xref" href="sec-io-user-spec-storage.html" title="7.3. Performing I/O with User-Specified Storage">Section 7.3, &#8220;Performing I/O with User-Specified Storage&#8221;</a>, you will learn how to
    perform I/O operations so that you can populate the matrix with real
    data.)</p><p>In C++, you can use the constructor syntax <code class="code">T()</code> to
    perform "default initialization" of a type <code class="code">T()</code>. The default
    value for any numeric type (including complex numbers) is zero. Therefore,
    the expression <code class="code">value_type()</code> indicates the complex number with
    zero as both its real and imaginary components. In the VSIPL++ API, when
    you assign a scalar value to a view (a vector, matrix, or tensor), all
    elements of the view are assigned the scalar value. So, the code below
    sets the contents of both the data matrix and replica vector to
    zero:</p><pre class="programlisting"> data = value_type();
 replica = value_type();</pre><p>The next step is to define the FFTs that will be performed.
    Typically (as in this example) an application performs multiple FFTs on
    inputs with the same size. Since performing an FFT requires that some
    set-up be performed before performing the actual FFT computation, it is
    more efficient to set up the FFT just once. Therefore, in the VSIPL++ API,
    FFTs are objects, rather than operators. Constructing the FFT performs the
    necessary set-up operations.</p><p>Because VSIPL++ supports a variety of different kinds of FFT, FFTs
    are themselves template classes. The parameters to the template allow you
    to indicate whether to perform a forward (time-domain to frequency-domain)
    or inverse (frequency-domain to time-domain) FFT, the type of the input
    and output data (i.e., whether complex or real data is in use), and so
    forth. Then, when constructing the FFT objects, you indicate the size of
    the FFT. In this case, you will need both an ordinary FFT (to convert the
    replica data from the time domain to the frequency domain) and a "multiple
    FFT" to perform the FFTs on the rows of the matrix. (A multiple FFT
    performs the same FFT on each row or column of a matrix.) So, the FFTs
    required are:</p><pre class="programlisting"> // A forward Fft for computing the frequency-domain version of
 // the replica.
 typedef Fft&lt;const_Vector, value_type,
             value_type, fft_fwd, by_reference&gt;
   for_fft_type;
 for_fft_type for_fft(Domain&lt;1&gt;(nrange), 1.0);
 // A forward Fftm for converting the time-domain data matrix to the
 // frequency domain.
 typedef Fftm&lt;value_type, value_type, row, fft_fwd, by_reference&gt;
   for_fftm_type;
 for_fftm_type for_fftm(Domain&lt;2&gt;(npulse, nrange), 1.0);
 // An inverse Fftm for converting the frequency-domain data back to
 // the time-domain.
 typedef Fftm&lt;value_type, value_type, row, fft_inv,
              by_reference&gt;
   inv_fftm_type;
 inv_fftm_type
    inv_fftm(Domain&lt;2&gt;(npulse, nrange), 1.0/(nrange));</pre><p>Before performing the actual convolution, you must convert the
    replica to the frequency domain using the FFT created above. Because the
    replica data is a property of the chirp, we only need to do this once;
    even if the radar system runs for a long time, the converted replica will
    always be the same. VSIPL++ FFT objects behave like functions, so you can
    just "call" the FFT object:</p><pre class="programlisting"> for_fft(replica);</pre><p>Now, you are ready to perform the actual fast convolution operation!
    You will use the forward and inverse multiple-FFT objects you've already
    created to go into and out of the frequency domain. While in the frequency
    domain, you will use the <code class="function">vmmul</code> operator to perform a
    vector-matrix multiply. This operator multiplies each row (dimension zero)
    of the frequency-domain matrix by the replica. The
    <code class="function">vmmul</code> operator is a template taking a single
    parameter which indicates whether the multiplication should be performed
    on rows or on columns. So, the heart of the fast convolution algorithm is
    just:</p><pre class="programlisting"> // Convert to the frequency domain.
 for_fftm(data, tmp);
 // Perform element-wise multiply for each pulse.
 tmp = vmmul&lt;0&gt;(replica, tmp);
 // Convert back to the time domain.
 inv_fftm(tmp, data);</pre><p>A complete program listing is show below. You can copy this program
    directly into your editor and build it. (You may notice that there are a
    few things in the complete listing not discussed above, including in
    particular, initialization of the library.)</p><pre class="programlisting">
      /***********************************************************************
  Included Files
***********************************************************************/

#include &lt;vsip/initfin.hpp&gt;
#include &lt;vsip/support.hpp&gt;
#include &lt;vsip/signal.hpp&gt;
#include &lt;vsip/math.hpp&gt;

using namespace vsip;



/***********************************************************************
  Main Program
***********************************************************************/

int
main(int argc, char** argv)
{
  // Initialize the library.
  vsipl vpp(argc, argv);

  typedef complex&lt;float&gt; value_type;

  // Parameters.
  length_type npulse = 64;	// number of pulses
  length_type nrange = 256;	// number of range cells

  // Views.
  Vector&lt;value_type&gt; replica(nrange);
  Matrix&lt;value_type&gt; data(npulse, nrange);
  Matrix&lt;value_type&gt; tmp(npulse, nrange);

  // A forward Fft for computing the frequency-domain version of
  // the replica.
  typedef Fft&lt;const_Vector, value_type, value_type, fft_fwd, by_reference&gt;
		for_fft_type;
  for_fft_type  for_fft (Domain&lt;1&gt;(nrange), 1.0);

  // A forward Fftm for converting the time-domain data matrix to the
  // frequency domain.
  typedef Fftm&lt;value_type, value_type, row, fft_fwd, by_reference&gt;
	  	for_fftm_type;
  for_fftm_type for_fftm(Domain&lt;2&gt;(npulse, nrange), 1.0);

  // An inverse Fftm for converting the frequency-domain data back to
  // the time-domain.
  typedef Fftm&lt;value_type, value_type, row, fft_inv, by_reference&gt;
	  	inv_fftm_type;
  inv_fftm_type inv_fftm(Domain&lt;2&gt;(npulse, nrange), 1.0/(nrange));

  // Initialize data to zero.
  data    = value_type();
  replica = value_type();

  // Before fast convolution, convert the replica to the the
  // frequency domain
  for_fft(replica);


  // Perform fast convolution.

  // Convert to the frequency domain.
  for_fftm(data, tmp);

  // Perform element-wise multiply for each pulse.
  tmp = vmmul&lt;0&gt;(replica, tmp);

  // Convert back to the time domain.
  inv_fftm(tmp, data);
}

    </pre><p>The following figure shows the performance in MFLOP/s of fast
    convolution on a 3.06 GHz Pentium Xeon processor as the number of range
    cells varies from 16 to 65536.</p><div class="mediaobject" align="center"><img src="images/par/fastconv-serial.png" align="middle"></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pt02.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="pt02.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sec-serial-temporal-locality.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part II. Example Application </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.2. Serial Optimization: Temporal Locality</td></tr></table></div></body></html>
