//
// Copyright (c) 2005, 2006, 2008 by CodeSourcery
// Copyright (c) 2013 Stefan Seefeld
// All rights reserved.
//
// This file is part of OpenVSIP. It is made available under the
// license contained in the accompanying LICENSE.GPL file.

#ifndef ILLEGALCASE
#  define ILLEGALCASE 0
#endif

#include <iostream>
#include <cassert>

#include <vsip/initfin.hpp>
#include <vsip/support.hpp>
#include <vsip/matrix.hpp>
#include <test.hpp>

using namespace ovxx;

template <typename T,
	  typename Block>
inline
std::ostream&
operator<<(std::ostream &out, const_Matrix<T, Block> matrix) VSIP_NOTHROW
{
  for (index_type i=0; i<matrix.size(); ++i)
    out << "  " << i << ": " << matrix.get(i) << "\n";
  return out;
}

/***********************************************************************
  Definitions - Utility Functions
***********************************************************************/

// check_size -- check the reported size of a matrix against
//               expected size

template <typename T,
	  typename Block>
void
check_size(const_Matrix<T, Block> matrix, length_type cols, length_type rows)
{
  test_assert(matrix.size() == cols * rows);
  test_assert(matrix.size(0) == cols);
  test_assert(matrix.size(1) == rows);
}



// fill_matrix -- fill a matrix with a sequence of values.
//
// Values are generated with a slope of K.

template <typename T,
	  typename Block>
void
fill_matrix(Matrix<T, Block> matrix, int k)
{
  for (index_type c = 0; c < matrix.size(0); ++c)
    for (index_type r = 0; r < matrix.size(1); ++r)
      matrix.put(c, r, T(k * c * r + 1));
}



// fill_block -- fill a block with sequence of values.
//
// Values are generated with a slope of K.

template <typename Block>
void
fill_block(Block& blk, int k)
{
  typedef typename Block::value_type T;

  for (index_type c = 0; c < blk.size(2, 0); ++c)
    for (index_type r = 0; r < blk.size(2, 1); ++r)
      blk.put(c, r, T(k * c * r + 1));
}



// test_matrix -- test values in matrix against sequence.
//
// Asserts that matrix values match those generated by a call to
// fill_matrix or fill_block with the same k value.

template <typename T,
	  typename Block>
void
test_matrix(const_Matrix<T, Block> matrix, int k)
{
  for (index_type c = 0; c < matrix.size(0); ++c)
    for (index_type r = 0; r < matrix.size(1); ++r)
      test_assert(equal(matrix.get(c, r), T(k * c * r + 1)));
}



// check_matrix -- check values in matrix against sequence.
//
// Checks that matrix values match those generated by a call to
// fill_matrix or fill_block with the same k value.  Rather than
// triggering test_assertion failure, check_matrix returns a boolean
// pass/fail that can be used to cause an test_assertion failure in
// the caller.

template <typename T,
	  typename Block>
bool
check_matrix(const_Matrix<T, Block> matrix, int k)
{
  for (index_type c = 0; c < matrix.size(0); ++c)
    for (index_type r = 0; r < matrix.size(1); ++r)
      if (!equal(matrix.get(c, r), T(k * c * r + 1)))
	return false;
  return true;
}



// check_not_alias -- check that two views are not aliased.
//
// Changes made to one should not effect the other.

template <template <typename, typename> class View1,
	  template <typename, typename> class View2,
	  typename T1,
	  typename T2,
	  typename Block1,
	  typename Block2>
void
check_not_alias(
  View1<T1, Block1>& matrix1,
  View2<T2, Block2>& matrix2)
{
  fill_block(matrix1.block(), 2);
  fill_block(matrix2.block(), 3);

  // Make sure that updates to matrix2 do not affect matrix1.
  test_assert(check_matrix(matrix1, 2));

  // And visa-versa.
  fill_block(matrix1.block(), 4);
  test_assert(check_matrix(matrix2, 3));
}



// check_alias -- check that two views are aliased.
//
// Changes made to one should effect the other.

template <template <typename, typename> class View1,
	  template <typename, typename> class View2,
	  typename T1,
	  typename T2,
	  typename Block1,
	  typename Block2>
void
check_alias(
  View1<T1, Block1>& matrix1,
  View2<T2, Block2>& matrix2)
{
  fill_block(matrix1.block(), 2);
  test_assert(check_matrix(matrix1, 2));
  test_assert(check_matrix(matrix2, 2));

  fill_block(matrix2.block(), 3);
  test_assert(check_matrix(matrix1, 3));
  test_assert(check_matrix(matrix2, 3));
}



/***********************************************************************
  Definitions - Matrix Test Cases.
***********************************************************************/

// -------------------------------------------------------------------- //
// test cases for get/put.

// tc_get -- test a matrix's get() member function.

template <typename                            T,
	  template <typename, typename> class View>
void
tc_get(length_type col, length_type row)
{
  View<T, Dense<2, T> > matrix(col, row);

  check_size(matrix, col, row);
  fill_block(matrix.block(), 2);
  test_matrix(matrix, 2);
}



template <typename T>
void
test_get_type(length_type col, length_type row)
{
  tc_get<T,       Matrix>(col, row);
  tc_get<T, const_Matrix>(col, row);
}


void test_get(length_type col, length_type row)
{
  test_get_type<scalar_f>(col, row);
  test_get_type<cscalar_f>(col, row);
  test_get_type<int>(col, row);
  // test_get_type<short>(col, row);
}


// -------------------------------------------------------------------- //
// test cases for get/put.

// tc_getput -- test a matrix's get() and put() member functions.

template <typename                            T,
	  template <typename, typename> class View>
void
tc_getput(length_type col, length_type row)
{
  View<T, Dense<2, T> > matrix(col, row);

  check_size(matrix, col, row);
  fill_matrix(matrix, 2);
  test_matrix(matrix, 2);
}



template <typename T>
void
test_getput_type(length_type col, length_type row)
{
  tc_getput<T,       Matrix>(col, row);
#if (ILLEGALCASE == 1)
  // const_Matrix should not provide put()
  tc_getput<T, const_Matrix>(col, row);
#endif
}



void test_getput(length_type col, length_type row)
{
  test_getput_type<scalar_f>(col, row);
  test_getput_type<cscalar_f>(col, row);
  test_getput_type<int>(col, row);
  // test_getput_type<short>(col, row);
}

// -------------------------------------------------------------------- //
// test cases for copy constructor.

template <typename T1,
	  typename T2,
	  template <typename, typename> class View1,
	  template <typename, typename> class View2>
void
tc_copy_cons(length_type col, length_type row, int k)
{
  View1<T1, Dense<2, T1> > matrix1(col, row);

  fill_block(matrix1.block(), k);

  View2<T2, Dense<2, T2> > matrix2(matrix1);

  test_matrix(matrix2, k);

  check_alias(matrix1, matrix2);
}



template <typename T1,
	  typename T2>
void
test_copy_cons_type(length_type col, length_type row, int k)
{
  tc_copy_cons<T1, T2,       Matrix,       Matrix>(col, row, k);
  tc_copy_cons<T1, T2,       Matrix, const_Matrix>(col, row, k);
  tc_copy_cons<T1, T2, const_Matrix, const_Matrix>(col, row, k);

#if (ILLEGALCASE == 2)
  // It should be illegal to construct a Matrix from a const_Matrix.
  tc_copy_cons<T1, T2, const_Matrix,       Matrix>(col, row, k);
#endif
}



void
test_copy_cons(length_type col, length_type row, int k)
{
  test_copy_cons_type<float, float>(col, row, k);
  // tc_copy_cons_set<  int,   int>(col, row, k);
}

// -------------------------------------------------------------------- //
// test cases for assignment

template <typename T1,
	  typename T2,
	  template <typename, typename> class View1,
	  template <typename, typename> class View2>
void
tc_assign(length_type col, length_type row, int k)
{
  View1<T1, Dense<2, T1> > matrix1(col, row);
  View2<T2, Dense<2, T2> > matrix2(col, row);

  fill_block(matrix1.block(), k);

  matrix2 = matrix1;

  test_assert(check_matrix(matrix2, k));

  check_not_alias(matrix1, matrix2);
}



template <typename T1,
	  typename T2>
void
test_assign_type(length_type col, length_type row, int k)
{
  tc_assign<T1, T2, Matrix,       Matrix>(col, row, k);
  tc_assign<T1, T2, const_Matrix, Matrix>(col, row, k);

#if (ILLEGALCASE == 3)
  tc_assign<T1, T2, Matrix,       const_Matrix>(col, row, k);
#endif
#if (ILLEGALCASE == 4)
  tc_assign<T1, T2, const_Matrix, const_Matrix>(col, row, k);
#endif
}



void
test_assign(length_type col, length_type row, int k)
{
  test_assign_type<float, float>(col, row, k);
}

// -------------------------------------------------------------------- //
// test cases for funcall

// tc_sum_const -- sum values in a const_Matrix.

template <typename T,
	  typename Block>
T
tc_sum_const(const_Matrix<T, Block> matrix)
{
  T sumval = T();
  for (index_type c = 0; c < matrix.size(0); ++c)
    for (index_type r = 0; r < matrix.size(1); ++r)
      sumval += matrix.get(c, r);
  return sumval;
}



// tc_sum -- sum values in a Matrix.

template <typename T,
	  typename Block>
T
tc_sum(Matrix<T, Block> matrix)
{
  T sumval = T();
  for (index_type c = 0; c < matrix.size(0); ++c)
    for (index_type r = 0; r < matrix.size(1); ++r)
      sumval += matrix.get(c, r);
  return sumval;
}



// tc_call_sum_const -- create View, pass it to tc_sum_const,
//                      check result.
template <typename T,
	  template <typename, typename> class View>
void
tc_call_sum_const(length_type col, length_type row, int k)
{
  View<T, Dense<2, T> > matrix1(col, row);

  fill_block(matrix1.block(), k);
  T sum = tc_sum_const(matrix1);

  test_assert(equal(sum, T(k*col*(col-1)*row*(row-1)/4+col*row)));
}



// tc_call_sum -- create View, pass it to tc_sum, check result.

template <typename T,
	  template <typename, typename> class View>
void
tc_call_sum(length_type col, length_type row, int k)
{
  View<T, Dense<2, T> > matrix1(col, row);

  fill_block(matrix1.block(), k);
  T sum = tc_sum(matrix1);

  test_assert(equal(sum, T(k*col*(col-1)*row*(row-1)/4+col*row)));
}



// test_call -- test that Matrix and const_Matrix can be passed
//              as arguments to functions.

void
test_call(length_type col, length_type row, int k)
{
  tc_call_sum_const<float, const_Matrix>(col, row, k);
  tc_call_sum_const<float,       Matrix>(col, row, k);

#if (ILLEGALCASE == 5)
  // should not be able to pass a const_Matrix to a routine
  // expecting a Matrix.
  tc_call_sum<float, const_Matrix>(col, row, k);
#endif
  tc_call_sum<float,       Matrix>(col, row, k);
}

// -------------------------------------------------------------------- //
// test cases for returning a view from a function.

// Generate a view/block of length LEN, with element 0 initialized
// to VAL.

template <template <typename, typename> class View,
	  typename			      T,
	  typename			      Block>
View<T, Block>
return_view(length_type col, length_type row, T val)
{
  Block* blk = new Block(Domain<2>(col, row));
  blk->put(0, 0, val);
  View<T, Block> vec(*blk);
  blk->decrement_count();

  return vec;
}



// Assign a view from the value of a function returning a view.

template <typename T,
	  template <typename, typename> class View1,
	  template <typename, typename> class View2>
void
tc_assign_return(length_type col, length_type row, T val)
{
  typedef Dense<2, T> block_type;
  View1<T, block_type> matrix1(col, row, T());

  test_assert(matrix1.get(0, 0) != val || val == T());

  matrix1 = return_view<View2, T, block_type>(col, row, val);

  test_assert(matrix1.get(0, 0) == val);
}



// Construct a view from the value of a function returning a view.

template <typename T,
	  template <typename, typename> class View1,
	  template <typename, typename> class View2>
void
tc_cons_return(length_type col, length_type row, T val)
{
  typedef Dense<2, T> block_type;

  View1<T, block_type> vec1(return_view<View2, T, block_type>(col, row, val));

  test_assert(vec1.get(0, 0) == val);
}



void
test_return()
{
  tc_assign_return<float,       Matrix,       Matrix>(10, 10, 1.0);
  tc_assign_return<float,       Matrix, const_Matrix>(10, 10, 1.0);

  // These cases are illegal: you cannot assign to a const_Matrix
#if ILLEGALCASE == 6
  tc_assign_return<float, const_Matrix, const_Matrix>(10, 10, 1.0);
#endif
#if ILLEGALCASE == 7
  tc_assign_return<float, const_Matrix,       Matrix>(10, 10, 1.0);
#endif

  tc_cons_return<float,       Matrix,       Matrix>(10, 10, 1.0);
  tc_cons_return<float,       Matrix, const_Matrix>(10, 10, 1.0);
  tc_cons_return<float, const_Matrix,       Matrix>(10, 10, 1.0);
  tc_cons_return<float, const_Matrix, const_Matrix>(10, 10, 1.0);
}


template <typename T>
void
tc_subview(Domain<2> const& dom, Domain<2> const& sub)
{
  Matrix<T> view(dom[0].length(), dom[1].length());

  fill_matrix(view, 2);

  typename Matrix<T>::subview_type        subv = view(sub);
  typename Matrix<T>::const_subview_type csubv = view.get(sub);

  for (index_type c = 0; c < sub[0].size(); ++c)
    for (index_type r = 0; r < sub[1].size(); ++r)
    {
      index_type parent_c = sub[0].impl_nth(c);
      index_type parent_r = sub[1].impl_nth(r);

      test_assert(view.get(parent_c, parent_r) ==  subv.get(c, r));
      test_assert(view.get(parent_c, parent_r) == csubv.get(c, r));

      view.put(parent_c, parent_r, view.get(parent_c, parent_r) + T(1));

      test_assert(view.get(parent_c, parent_r) ==  subv.get(c, r));
      test_assert(view.get(parent_c, parent_r) == csubv.get(c, r));

      subv.put(c, r, subv.get(c, r) + T(1));

      test_assert(view.get(parent_c, parent_r) ==  subv.get(c, r));
      test_assert(view.get(parent_c, parent_r) == csubv.get(c, r));
    }
}


void
test_subview()
{
  tc_subview<float>(Domain<2>(10, 10),
		    Domain<2>(Domain<1>(0, 1, 3), Domain<1>(10)));
  tc_subview<float>(Domain<2>(10, 10),
		    Domain<2>(Domain<1>(5, 1, 3), Domain<1>(10)));
  tc_subview<float>(Domain<2>(10, 10),
		    Domain<2>(Domain<1>(0, 2, 3), Domain<1>(10)));
  tc_subview<float>(Domain<2>(10, 10),
		    Domain<2>(Domain<1>(5, 2, 3), Domain<1>(10)));

  tc_subview<float>(Domain<2>(10, 10),
		    Domain<2>(Domain<1>(10), Domain<1>(0, 1, 3)));
  tc_subview<float>(Domain<2>(10, 10),
		    Domain<2>(Domain<1>(10), Domain<1>(5, 1, 3)));
  tc_subview<float>(Domain<2>(10, 10),
		    Domain<2>(Domain<1>(10), Domain<1>(0, 2, 3)));
  tc_subview<float>(Domain<2>(10, 10),
		    Domain<2>(Domain<1>(10), Domain<1>(5, 2, 3)));

  tc_subview<complex<float> >(Domain<2>(10, 10),
			      Domain<2>(Domain<1>(0, 1, 3), Domain<1>(10)));
  tc_subview<complex<float> >(Domain<2>(10, 10),
			      Domain<2>(Domain<1>(5, 1, 3), Domain<1>(10)));
  tc_subview<complex<float> >(Domain<2>(10, 10),
			      Domain<2>(Domain<1>(0, 2, 3), Domain<1>(10)));
  tc_subview<complex<float> >(Domain<2>(10, 10),
			      Domain<2>(Domain<1>(5, 2, 3), Domain<1>(10)));

  tc_subview<complex<float> >(Domain<2>(10, 10),
			      Domain<2>(Domain<1>(10), Domain<1>(0, 1, 3)));
  tc_subview<complex<float> >(Domain<2>(10, 10),
			      Domain<2>(Domain<1>(10), Domain<1>(5, 1, 3)));
  tc_subview<complex<float> >(Domain<2>(10, 10),
			      Domain<2>(Domain<1>(10), Domain<1>(0, 2, 3)));
  tc_subview<complex<float> >(Domain<2>(10, 10),
			      Domain<2>(Domain<1>(10), Domain<1>(5, 2, 3)));

  tc_subview<int>(Domain<2>(10, 10),
		  Domain<2>(Domain<1>(0, 1, 3), Domain<1>(10)));
  tc_subview<int>(Domain<2>(10, 10),
		  Domain<2>(Domain<1>(5, 1, 3), Domain<1>(10)));
  tc_subview<int>(Domain<2>(10, 10),
		  Domain<2>(Domain<1>(0, 2, 3), Domain<1>(10)));
  tc_subview<int>(Domain<2>(10, 10),
		  Domain<2>(Domain<1>(5, 2, 3), Domain<1>(10)));
  tc_subview<int>(Domain<2>(10, 10),
		  Domain<2>(Domain<1>(10), Domain<1>(0, 1, 3)));
  tc_subview<int>(Domain<2>(10, 10),
		  Domain<2>(Domain<1>(10), Domain<1>(5, 1, 3)));
  tc_subview<int>(Domain<2>(10, 10),
		  Domain<2>(Domain<1>(10), Domain<1>(0, 2, 3)));
  tc_subview<int>(Domain<2>(10, 10),
		  Domain<2>(Domain<1>(10), Domain<1>(5, 2, 3)));
}

void
test_complex()
{
  typedef Matrix<std::complex<double> > CMatrix;
  CMatrix cm(2, 2, 3.);
  CMatrix::realview_type rm = cm.real();
  CMatrix::imagview_type im = cm.imag();
  CMatrix::const_realview_type crm = const_cast<CMatrix const&>(cm).real();
  CMatrix::const_imagview_type cim = const_cast<CMatrix const&>(cm).imag();
  cm.put(0, 0, 5.);
  cm.put(1, 0, 5.);
  cm.put(0, 1, 5.);
  cm.put(1, 1, 5.);
  test_assert(equal(20., tc_sum(rm)));
  test_assert(equal(0., tc_sum(im)));
  test_assert(equal(20., tc_sum_const(crm)));
  test_assert(equal(0., tc_sum_const(cim)));
  rm.put(0, 0, 0.);
  rm.put(1, 0, 0.);
  rm.put(0, 1, 0.);
  rm.put(1, 1, 0.);
  im.put(0, 0, 5.);
  im.put(1, 0, 5.);
  im.put(0, 1, 5.);
  im.put(1, 1, 5.);
  test_assert(equal(0., tc_sum(rm)));
  test_assert(equal(20., tc_sum(im)));
  test_assert(equal(0., tc_sum_const(crm)));
  test_assert(equal(20., tc_sum_const(cim)));
}

void
test_const_complex()
{
  typedef const_Matrix<std::complex<double> > CMatrix;
  CMatrix cm(2, 2, 5.);
  CMatrix::const_realview_type crm = cm.real();
  CMatrix::const_imagview_type cim = cm.imag();
  test_assert(equal(20., tc_sum_const(crm)));
  test_assert(equal(0., tc_sum_const(cim)));
}

void
test_col()
{
  Matrix<double> m(2, 2, 3.);
  Matrix<double>::col_type cm = m.col(0);
  Matrix<double>::const_col_type ccm = const_cast<Matrix<double> const&>(m).col(1);
  m.put(0, 0, 1.);
  m.put(1, 0, 2.);
  m.put(0, 1, 3.);
  m.put(1, 1, 4.);
  test_assert(equal(1., cm.get(0)));  // m(0, 0)
  test_assert(equal(2., cm.get(1)));  // m(1, 0)
  test_assert(equal(3., ccm.get(0))); // m(0, 1)
  test_assert(equal(4., ccm.get(1))); // m(1, 1)
  cm.put(0, 0.);
  cm.put(1, 0.);
  test_assert(equal(0., cm.get(0)));
  test_assert(equal(0., cm.get(1)));
  test_assert(equal(3., ccm.get(0)));
  test_assert(equal(4., ccm.get(1)));


  length_type const num_rows = 8;
  length_type const num_cols = 16;

  Matrix<double> m2(num_rows, num_cols);
  Matrix<double>::col_type cm2 = m2.col(0);
  Matrix<double>::const_col_type ccm2 =
    const_cast<Matrix<double> const&>(m2).col(1);

  test_assert(cm2.length()  == num_rows); // column length == number of rows
  test_assert(ccm2.length() == num_rows); // column length == number of rows

  for (index_type r=0; r<num_rows; ++r)
    for (index_type c=0; c<num_rows; ++c)
      m2.put(r, c, 1.0*r*num_cols+c);

  for (index_type i=0; i<num_rows; ++i)
  {
    test_assert(cm2.get(i)  == m2.get(i, 0));
    test_assert(ccm2.get(i) == m2.get(i, 1));
  }
}

void
test_const_col()
{
  const_Matrix<double> m(2, 2, 3.);
  const_Matrix<double>::const_col_type cm1 = m.col(0);
  const_Matrix<double>::const_col_type cm2 = m.col(1);
  test_assert(equal(3., cm1.get(0)));
  test_assert(equal(3., cm1.get(1)));
  test_assert(equal(3., cm2.get(0)));
  test_assert(equal(3., cm2.get(1)));
}

void
test_row()
{
  Matrix<double> m(2, 2, 3.);
  Matrix<double>::row_type rm = m.row(0);
  Matrix<double>::const_row_type crm = const_cast<Matrix<double> const&>(m).row(1);
  m.put(0, 0, 1.);
  m.put(1, 0, 2.);
  m.put(0, 1, 3.);
  m.put(1, 1, 4.);
  test_assert(equal(1., rm.get(0)));  // m(0, 0)
  test_assert(equal(3., rm.get(1)));  // m(0, 1)
  test_assert(equal(2., crm.get(0))); // m(1, 0)
  test_assert(equal(4., crm.get(1))); // m(1, 1)
  rm.put(0, 0.);
  rm.put(1, 0.);
  test_assert(equal(0., rm.get(0)));
  test_assert(equal(0., rm.get(1)));
  test_assert(equal(2., crm.get(0)));
  test_assert(equal(4., crm.get(1)));


  length_type const num_rows = 8;
  length_type const num_cols = 16;

  Matrix<double> m2(num_rows, num_cols);
  Matrix<double>::row_type rm2 = m2.row(0);
  Matrix<double>::const_row_type crm2 =
    const_cast<Matrix<double> const&>(m2).row(1);

  test_assert(rm2.length()  == num_cols); // row length == number of columns
  test_assert(crm2.length() == num_cols); // row length == number of columns

  for (index_type r=0; r<num_rows; ++r)
    for (index_type c=0; c<num_rows; ++c)
      m2.put(r, c, 1.0*r*num_cols+c);

  for (index_type i=0; i<num_rows; ++i)
  {
    test_assert(rm2.get(i)  == m2.get(0, i));
    test_assert(crm2.get(i) == m2.get(1, i));
  }

}

void
test_const_row()
{
  const_Matrix<double> m(2, 2, 3.);
  const_Matrix<double>::const_row_type rm1 = m.row(0);
  const_Matrix<double>::const_row_type rm2 = m.row(1);
  test_assert(equal(3., rm1.get(0)));
  test_assert(equal(3., rm1.get(1)));
  test_assert(equal(3., rm2.get(0)));
  test_assert(equal(3., rm2.get(1)));
}

#define VSIP_TEST_ELEMENTWISE_SCALAR(x, op, y) \
{                                              \
  Matrix<int> m(1, 1, x);		       \
  Matrix<int> &m1 = (m op y);		       \
  int r = x;                                   \
  r op y;                                      \
  test_assert(&m1 == &m && equal(m1.get(0, 0), r)); \
}

#define VSIP_TEST_ELEMENTWISE_MATRIX(x, op, y) \
{                                              \
  Matrix<int> m(1, 1, x);		       \
  Matrix<int> n(1, 1, y);		       \
  Matrix<int> &m1 = (m op n);		       \
  int r = x;                                   \
  r op y;                                      \
  test_assert(&m1 == &m && equal(m1.get(0, 0), r)); \
}

int
main(int argc, char** argv)
{
  vsip::vsipl init(argc, argv);

  test_get(10, 10);
  test_getput(10, 10);

  test_copy_cons(10, 10, 3);
  test_assign(10, 10, 3);

  test_call(10, 10, 3);

  test_subview();

  test_complex();
  test_const_complex();

  VSIP_TEST_ELEMENTWISE_SCALAR(4, +=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, -=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, *=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, /=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, &=, 3)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, &=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, |=, 3)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, |=, 2)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, ^=, 3)
  VSIP_TEST_ELEMENTWISE_SCALAR(4, ^=, 2)

  VSIP_TEST_ELEMENTWISE_MATRIX(4, +=, 2)
  VSIP_TEST_ELEMENTWISE_MATRIX(4, -=, 2)
  VSIP_TEST_ELEMENTWISE_MATRIX(4, *=, 2)
  VSIP_TEST_ELEMENTWISE_MATRIX(4, /=, 2)
  VSIP_TEST_ELEMENTWISE_MATRIX(4, &=, 3)
  VSIP_TEST_ELEMENTWISE_MATRIX(4, &=, 2)
  VSIP_TEST_ELEMENTWISE_MATRIX(4, |=, 3)
  VSIP_TEST_ELEMENTWISE_MATRIX(4, |=, 2)
  VSIP_TEST_ELEMENTWISE_MATRIX(4, ^=, 3)
  VSIP_TEST_ELEMENTWISE_MATRIX(4, ^=, 2)

  test_col();
  test_const_col();

  test_row();
  test_const_row();
}
